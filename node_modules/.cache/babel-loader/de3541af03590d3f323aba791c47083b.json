{"ast":null,"code":"/**\r\n * Expose `pathtoRegexp`.\r\n */\nmodule.exports = pathtoRegexp;\n/**\r\n * Match matching groups in a regular expression.\r\n */\n\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\n/**\r\n * Normalize the given path string,\r\n * returning a regular expression.\r\n *\r\n * An empty array should be passed,\r\n * which will contain the placeholder\r\n * key names. For example \"/user/:id\" will\r\n * then contain [\"id\"].\r\n *\r\n * @param  {String|RegExp|Array} path\r\n * @param  {Array} keys\r\n * @param  {Object} options\r\n * @return {RegExp}\r\n * @api private\r\n */\n\nfunction pathtoRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var m;\n\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      keys.push({\n        name: name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathtoRegexp(value, keys, options).source;\n    });\n    return new RegExp('(?:' + path.join('|') + ')', flags);\n  }\n\n  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?')).replace(/\\/\\(/g, '/(?:').replace(/([\\/\\.])/g, '\\\\$1').replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n    slash = slash || '';\n    format = format || '';\n    capture = capture || '([^\\\\/' + format + ']+?)';\n    optional = optional || '';\n    keys.push({\n      name: key,\n      optional: !!optional,\n      offset: offset + extraOffset\n    });\n    var result = '' + (optional ? '' : slash) + '(?:' + format + (optional ? slash : '') + capture + (star ? '((?:[\\\\/' + format + '].+?)?)' : '') + ')' + optional;\n    extraOffset += result.length - match.length;\n    return result;\n  }).replace(/\\*/g, function (star, index) {\n    var len = keys.length;\n\n    while (len-- > keysOffset && keys[len].offset > index) {\n      keys[len].offset += 3; // Replacement length minus asterisk length.\n    }\n\n    return '(.*)';\n  }); // This is a workaround for handling unnamed matching groups.\n\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    var escapeCount = 0;\n    var index = m.index;\n\n    while (path.charAt(--index) === '\\\\') {\n      escapeCount++;\n    } // It's possible to escape the bracket.\n\n\n    if (escapeCount % 2 === 1) {\n      continue;\n    }\n\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++,\n        // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    i++;\n  } // If the path is non-ending, match until the end or a slash.\n\n\n  path += end ? '$' : path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)';\n  return new RegExp(path, flags);\n}\n\n;","map":{"version":3,"sources":["c:/Users/JYOTI95/Documents/GitHub/DCIPL/node_modules/path-to-regexp/index.js"],"names":["module","exports","pathtoRegexp","MATCHING_GROUP_REGEXP","path","keys","options","strict","end","flags","sensitive","extraOffset","keysOffset","length","i","name","m","RegExp","exec","source","push","optional","offset","index","Array","isArray","map","value","join","replace","match","slash","format","key","capture","star","result","len","escapeCount","charAt","splice"],"mappings":"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","sourcesContent":["/**\r\n * Expose `pathtoRegexp`.\r\n */\r\n\r\nmodule.exports = pathtoRegexp;\r\n\r\n/**\r\n * Match matching groups in a regular expression.\r\n */\r\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\r\n\r\n/**\r\n * Normalize the given path string,\r\n * returning a regular expression.\r\n *\r\n * An empty array should be passed,\r\n * which will contain the placeholder\r\n * key names. For example \"/user/:id\" will\r\n * then contain [\"id\"].\r\n *\r\n * @param  {String|RegExp|Array} path\r\n * @param  {Array} keys\r\n * @param  {Object} options\r\n * @return {RegExp}\r\n * @api private\r\n */\r\n\r\nfunction pathtoRegexp(path, keys, options) {\r\n  options = options || {};\r\n  keys = keys || [];\r\n  var strict = options.strict;\r\n  var end = options.end !== false;\r\n  var flags = options.sensitive ? '' : 'i';\r\n  var extraOffset = 0;\r\n  var keysOffset = keys.length;\r\n  var i = 0;\r\n  var name = 0;\r\n  var m;\r\n\r\n  if (path instanceof RegExp) {\r\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\r\n      keys.push({\r\n        name: name++,\r\n        optional: false,\r\n        offset: m.index\r\n      });\r\n    }\r\n\r\n    return path;\r\n  }\r\n\r\n  if (Array.isArray(path)) {\r\n    // Map array parts into regexps and return their source. We also pass\r\n    // the same keys and options instance into every generation to get\r\n    // consistent matching groups before we join the sources together.\r\n    path = path.map(function (value) {\r\n      return pathtoRegexp(value, keys, options).source;\r\n    });\r\n\r\n    return new RegExp('(?:' + path.join('|') + ')', flags);\r\n  }\r\n\r\n  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))\r\n    .replace(/\\/\\(/g, '/(?:')\r\n    .replace(/([\\/\\.])/g, '\\\\$1')\r\n    .replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\r\n      slash = slash || '';\r\n      format = format || '';\r\n      capture = capture || '([^\\\\/' + format + ']+?)';\r\n      optional = optional || '';\r\n\r\n      keys.push({\r\n        name: key,\r\n        optional: !!optional,\r\n        offset: offset + extraOffset\r\n      });\r\n\r\n      var result = ''\r\n        + (optional ? '' : slash)\r\n        + '(?:'\r\n        + format + (optional ? slash : '') + capture\r\n        + (star ? '((?:[\\\\/' + format + '].+?)?)' : '')\r\n        + ')'\r\n        + optional;\r\n\r\n      extraOffset += result.length - match.length;\r\n\r\n      return result;\r\n    })\r\n    .replace(/\\*/g, function (star, index) {\r\n      var len = keys.length\r\n\r\n      while (len-- > keysOffset && keys[len].offset > index) {\r\n        keys[len].offset += 3; // Replacement length minus asterisk length.\r\n      }\r\n\r\n      return '(.*)';\r\n    });\r\n\r\n  // This is a workaround for handling unnamed matching groups.\r\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\r\n    var escapeCount = 0;\r\n    var index = m.index;\r\n\r\n    while (path.charAt(--index) === '\\\\') {\r\n      escapeCount++;\r\n    }\r\n\r\n    // It's possible to escape the bracket.\r\n    if (escapeCount % 2 === 1) {\r\n      continue;\r\n    }\r\n\r\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\r\n      keys.splice(keysOffset + i, 0, {\r\n        name: name++, // Unnamed matching groups must be consistently linear.\r\n        optional: false,\r\n        offset: m.index\r\n      });\r\n    }\r\n\r\n    i++;\r\n  }\r\n\r\n  // If the path is non-ending, match until the end or a slash.\r\n  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)'));\r\n\r\n  return new RegExp(path, flags);\r\n};\r\n"]},"metadata":{},"sourceType":"script"}